---
timestamp: 'Mon Nov 03 2025 18:36:22 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251103_183622.68abe396.md]]'
content_id: 066c96f49a4a3bbf210b06e897972338dbc79513f0232b1546a0f3939a3ed050
---

# Synchronization Implementations

These files would be placed in your `src/syncs/` directory. Remember to run `deno run build` after creating these files to ensure `@concepts` is correctly updated.

## 1. `auth.sync.ts` (for UserAuthentication)

This file handles the HTTP request/response flow for user registration and authentication using the `UserAuthentication` concept.

**File:** `src/syncs/auth.sync.ts`

```typescript
// These two help you declare synchronizations
import { actions, Sync } from "@engine";
// Choose whatever concepts you have
import { Requesting, UserAuthentication } from "@concepts";

// --- User Registration Syncs ---

/**
 * RegisterUserRequest:
 * when Requesting.request (path: "/auth/register", username, password) : (request)
 * then UserAuthentication.register (username, password) : (user, error)
 *
 * Handles incoming HTTP requests to register a new user.
 * Maps the username and password from the request body to the UserAuthentication.register action.
 */
export const RegisterUserRequest: Sync = ({ request, username, password, user, error }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/register", username, password }, { request }],
    ),
    then: actions(
        [UserAuthentication.register, { username, password }, { user, error }],
    ),
});

/**
 * RegisterUserResponseSuccess:
 * when Requesting.request (path: "/auth/register") : (request)
 *      UserAuthentication.register () : (user)
 * then Requesting.respond (request, user)
 *
 * Responds to the client with the new user's ID upon successful registration.
 */
export const RegisterUserResponseSuccess: Sync = ({ request, user }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/register" }, { request }],
        [UserAuthentication.register, {}, { user }], // Matches successful registration (has 'user' output)
    ),
    then: actions(
        [Requesting.respond, { request, user }],
    ),
});

/**
 * RegisterUserResponseError:
 * when Requesting.request (path: "/auth/register") : (request)
 *      UserAuthentication.register () : (error)
 * then Requesting.respond (request, error)
 *
 * Responds to the client with an error message if registration fails.
 */
export const RegisterUserResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/register" }, { request }],
        [UserAuthentication.register, {}, { error }], // Matches failed registration (has 'error' output)
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

// --- User Authentication/Login Syncs ---

/**
 * AuthenticateUserRequest:
 * when Requesting.request (path: "/auth/login", username, password) : (request)
 * then UserAuthentication.authenticate (username, password) : (user, error)
 *
 * Handles incoming HTTP requests to authenticate (log in) a user.
 * Maps the username and password from the request body to the UserAuthentication.authenticate action.
 */
export const AuthenticateUserRequest: Sync = ({ request, username, password, user, error }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/login", username, password }, { request }],
    ),
    then: actions(
        [UserAuthentication.authenticate, { username, password }, { user, error }],
    ),
});

/**
 * AuthenticateUserResponseSuccess:
 * when Requesting.request (path: "/auth/login") : (request)
 *      UserAuthentication.authenticate () : (user)
 * then Requesting.respond (request, user)
 *
 * Responds to the client with the authenticated user's ID upon successful login.
 * In a full application, this is where a session token might be created and returned.
 */
export const AuthenticateUserResponseSuccess: Sync = ({ request, user }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/login" }, { request }],
        [UserAuthentication.authenticate, {}, { user }], // Matches successful authentication (has 'user' output)
    ),
    then: actions(
        [Requesting.respond, { request, user }],
    ),
});

/**
 * AuthenticateUserResponseError:
 * when Requesting.request (path: "/auth/login") : (request)
 *      UserAuthentication.authenticate () : (error)
 * then Requesting.respond (request, error)
 *
 * Responds to the client with an error message if authentication fails.
 */
export const AuthenticateUserResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/login" }, { request }],
        [UserAuthentication.authenticate, {}, { error }], // Matches failed authentication (has 'error' output)
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

```

## 2. `brontoboard.sync.ts` (for BrontoBoard)

This file implements synchronizations for all `BrontoBoard` actions and queries, ensuring that user authentication (via a hypothetical `Sessioning` concept) is performed for actions requiring an `owner`.

**File:** `src/syncs/brontoboard.sync.ts`

```typescript
import { actions, Sync, Frames } from "@engine";
import { Requesting, BrontoBoard, Sessioning } from "@concepts"; // ASSUMPTION: Sessioning concept is available
import { ID } from "@utils/types.ts";

// --- Helper for Authenticated User Retrieval ---
// This function encapsulates the common pattern of retrieving a user ID from a session ID.
// It queries the Sessioning concept, binding the result to the 'user' symbol.
// If no user is found for the session, the frames array will become empty.
const getAuthenticatedUser = async (frames: Frames, sessionSymbol: symbol, userSymbol: symbol) => {
    // We assume Sessioning._getUser exists and returns { user: ID }
    // If Sessioning returns multiple users (e.g., if a session could have multiple active users),
    // you might need additional logic. Here, we assume a 1:1 mapping.
    return await frames.query(Sessioning._getUser, { session: sessionSymbol }, { user: userSymbol });
};

// --- BrontoBoard Initialization Syncs ---

/**
 * InitializeBrontoBoardRequest:
 * when Requesting.request (path: "/brontoboard/initialize", session, calendar) : (request)
 * where in Sessioning: session is valid and maps to user
 * then BrontoBoard.initializeBB (user, calendar) : (brontoBoard, error)
 *
 * Handles requests to create a new BrontoBoard. Requires an authenticated user and a calendar ID.
 */
export const InitializeBrontoBoardRequest: Sync = ({ request, session, user, calendar, brontoBoard, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/initialize", session, calendar }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0]; // Capture initial frame for potential error response
        frames = await getAuthenticatedUser(frames, session, user); // Get authenticated user from session
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Authentication required: Invalid session." }]);
        }
        return frames;
    },
    then: actions(
        [BrontoBoard.initializeBB, { user, calendar }, { brontoBoard, error }],
    ),
});

/**
 * InitializeBrontoBoardResponseSuccess:
 * when Requesting.request (path: "/brontoboard/initialize") : (request)
 *      BrontoBoard.initializeBB () : (brontoBoard)
 * then Requesting.respond (request, brontoBoard)
 *
 * Responds to a successful BrontoBoard creation with the new BrontoBoard's ID.
 */
export const InitializeBrontoBoardResponseSuccess: Sync = ({ request, brontoBoard }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/initialize" }, { request }],
        [BrontoBoard.initializeBB, {}, { brontoBoard }],
    ),
    then: actions(
        [Requesting.respond, { request, brontoBoard }],
    ),
});

/**
 * InitializeBrontoBoardResponseError:
 * when Requesting.request (path: "/brontoboard/initialize") : (request)
 *      BrontoBoard.initializeBB () : (error)
 * then Requesting.respond (request, error)
 *
 * Responds to an error during BrontoBoard creation.
 */
export const InitializeBrontoBoardResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/initialize" }, { request }],
        [BrontoBoard.initializeBB, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

// --- Class Management Syncs ---

/**
 * CreateClassRequest:
 * when Requesting.request (path: "/brontoboard/class/create", session, brontoBoard, className, overview) : (request)
 * where in Sessioning: session is valid and maps to owner
 * then BrontoBoard.createClass (owner, brontoBoard, className, overview) : (class, error)
 *
 * Handles requests to create a new Class within a BrontoBoard.
 * Requires an authenticated user (as owner) and the BrontoBoard ID.
 */
export const CreateClassRequest: Sync = (
    { request, session, owner, brontoBoard, className, overview, class: classId, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/class/create", session, brontoBoard, className, overview }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Authentication required: Invalid session." }]);
        }
        // BrontoBoard.createClass action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.createClass, { owner, brontoBoard, className, overview }, { class: classId, error }],
    ),
});

/**
 * CreateClassResponseSuccess:
 * when Requesting.request (path: "/brontoboard/class/create") : (request)
 *      BrontoBoard.createClass () : (class)
 * then Requesting.respond (request, class)
 *
 * Responds to a successful Class creation with the new Class's ID.
 */
export const CreateClassResponseSuccess: Sync = ({ request, class: classId }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/class/create" }, { request }],
        [BrontoBoard.createClass, {}, { class: classId }],
    ),
    then: actions(
        [Requesting.respond, { request, class: classId }],
    ),
});

/**
 * CreateClassResponseError:
 * when Requesting.request (path: "/brontoboard/class/create") : (request)
 *      BrontoBoard.createClass () : (error)
 * then Requesting.respond (request, error)
 *
 * Responds to an error during Class creation.
 */
export const CreateClassResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/class/create" }, { request }],
        [BrontoBoard.createClass, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

// --- Assignment (Work) Management Syncs ---

/**
 * AddWorkRequest:
 * when Requesting.request (path: "/brontoboard/work/add", session, class, workName, dueDate) : (request)
 * where in Sessioning: session is valid and maps to owner
 * then BrontoBoard.addWork (owner, class, workName, dueDate) : (assignment, error)
 *
 * Handles requests to add a new Assignment to a Class.
 * Requires an authenticated user (as owner) and class ID.
 */
export const AddWorkRequest: Sync = (
    { request, session, owner, class: classId, workName, dueDate, assignment, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/add", session, class: classId, workName, dueDate }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Authentication required: Invalid session." }]);
        }
        // BrontoBoard.addWork action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.addWork, { owner, class: classId, workName, dueDate }, { assignment, error }],
    ),
});

/**
 * AddWorkResponseSuccess:
 * when Requesting.request (path: "/brontoboard/work/add") : (request)
 *      BrontoBoard.addWork () : (assignment)
 * then Requesting.respond (request, assignment)
 *
 * Responds to a successful Assignment addition with the new Assignment's ID.
 */
export const AddWorkResponseSuccess: Sync = ({ request, assignment }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/add" }, { request }],
        [BrontoBoard.addWork, {}, { assignment }],
    ),
    then: actions(
        [Requesting.respond, { request, assignment }],
    ),
});

/**
 * AddWorkResponseError:
 * when Requesting.request (path: "/brontoboard/work/add") : (request)
 *      BrontoBoard.addWork () : (error)
 * then Requesting.respond (request, error)
 *
 * Responds to an error during Assignment addition.
 */
export const AddWorkResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/add" }, { request }],
        [BrontoBoard.addWork, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

/**
 * ChangeWorkRequest:
 * when Requesting.request (path: "/brontoboard/work/change", session, work, dueDate) : (request)
 * where in Sessioning: session is valid and maps to owner
 * then BrontoBoard.changeWork (owner, work, dueDate) : (error)
 *
 * Handles requests to change an existing Assignment's due date.
 * Requires an authenticated user (as owner) and Assignment ID.
 */
export const ChangeWorkRequest: Sync = (
    { request, session, owner, work, dueDate, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/change", session, work, dueDate }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Authentication required: Invalid session." }]);
        }
        // BrontoBoard.changeWork action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.changeWork, { owner, work, dueDate }, { error }],
    ),
});

/**
 * ChangeWorkResponseSuccess:
 * when Requesting.request (path: "/brontoboard/work/change") : (request)
 *      BrontoBoard.changeWork () : ()
 * then Requesting.respond (request, status: "ok")
 *
 * Responds to a successful Assignment modification.
 */
export const ChangeWorkResponseSuccess: Sync = ({ request }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/change" }, { request }],
        [BrontoBoard.changeWork, {}, {}], // No output variable on success
    ),
    then: actions(
        [Requesting.respond, { request, status: "ok" }],
    ),
});

/**
 * ChangeWorkResponseError:
 * when Requesting.request (path: "/brontoboard/work/change") : (request)
 *      BrontoBoard.changeWork () : (error)
 * then Requesting.respond (request, error)
 *
 * Responds to an error during Assignment modification.
 */
export const ChangeWorkResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/change" }, { request }],
        [BrontoBoard.changeWork, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

/**
 * RemoveWorkRequest:
 * when Requesting.request (path: "/brontoboard/work/remove", session, work) : (request)
 * where in Sessioning: session is valid and maps to owner
 * then BrontoBoard.removeWork (owner, work) : (error)
 *
 * Handles requests to remove an Assignment.
 * Requires an authenticated user (as owner) and Assignment ID.
 */
export const RemoveWorkRequest: Sync = (
    { request, session, owner, work, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/remove", session, work }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Authentication required: Invalid session." }]);
        }
        // BrontoBoard.removeWork action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.removeWork, { owner, work }, { error }],
    ),
});

/**
 * RemoveWorkResponseSuccess:
 * when Requesting.request (path: "/brontoboard/work/remove") : (request)
 *      BrontoBoard.removeWork () : ()
 * then Requesting.respond (request, status: "ok")
 *
 * Responds to a successful Assignment removal.
 */
export const RemoveWorkResponseSuccess: Sync = ({ request }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/remove" }, { request }],
        [BrontoBoard.removeWork, {}, {}], // No output variable on success
    ),
    then: actions(
        [Requesting.respond, { request, status: "ok" }],
    ),
});

/**
 * RemoveWorkResponseError:
 * when Requesting.request (path: "/brontoboard/work/remove") : (request)
 *      BrontoBoard.removeWork () : (error)
 * then Requesting.respond (request, error)
 *
 * Responds to an error during Assignment removal.
 */
export const RemoveWorkResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/remove" }, { request }],
        [BrontoBoard.removeWork, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

// --- Office Hours Management Syncs ---

/**
 * AddOHRequest:
 * when Requesting.request (path: "/brontoboard/officehours/add", session, class, OHTime, OHduration) : (request)
 * where in Sessioning: session is valid and maps to owner
 * then BrontoBoard.addOH (owner, class, OHTime, OHduration) : (officeHours, error)
 *
 * Handles requests to add new Office Hours to a Class.
 * Requires an authenticated user (as owner) and Class ID.
 */
export const AddOHRequest: Sync = (
    { request, session, owner, class: classId, OHTime, OHduration, officeHours, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/add", session, class: classId, OHTime, OHduration }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Authentication required: Invalid session." }]);
        }
        // BrontoBoard.addOH action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.addOH, { owner, class: classId, OHTime, OHduration }, { officeHours, error }],
    ),
});

/**
 * AddOHResponseSuccess:
 * when Requesting.request (path: "/brontoboard/officehours/add") : (request)
 *      BrontoBoard.addOH () : (officeHours)
 * then Requesting.respond (request, officeHours)
 *
 * Responds to a successful Office Hours addition with the new OfficeHours' ID.
 */
export const AddOHResponseSuccess: Sync = ({ request, officeHours }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/add" }, { request }],
        [BrontoBoard.addOH, {}, { officeHours }],
    ),
    then: actions(
        [Requesting.respond, { request, officeHours }],
    ),
});

/**
 * AddOHResponseError:
 * when Requesting.request (path: "/brontoboard/officehours/add") : (request)
 *      BrontoBoard.addOH () : (error)
 * then Requesting.respond (request, error)
 *
 * Responds to an error during Office Hours addition.
 */
export const AddOHResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/add" }, { request }],
        [BrontoBoard.addOH, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

/**
 * ChangeOHRequest:
 * when Requesting.request (path: "/brontoboard/officehours/change", session, oh, newDate, newduration) : (request)
 * where in Sessioning: session is valid and maps to owner
 * then BrontoBoard.changeOH (owner, oh, newDate, newduration) : (error)
 *
 * Handles requests to change existing Office Hours.
 * Requires an authenticated user (as owner) and Office Hour ID.
 */
export const ChangeOHRequest: Sync = (
    { request, session, owner, oh, newDate, newduration, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/change", session, oh, newDate, newduration }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Authentication required: Invalid session." }]);
        }
        // BrontoBoard.changeOH action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.changeOH, { owner, oh, newDate, newduration }, { error }],
    ),
});

/**
 * ChangeOHResponseSuccess:
 * when Requesting.request (path: "/brontoboard/officehours/change") : (request)
 *      BrontoBoard.changeOH () : ()
 * then Requesting.respond (request, status: "ok")
 *
 * Responds to a successful Office Hours modification.
 */
export const ChangeOHResponseSuccess: Sync = ({ request }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/change" }, { request }],
        [BrontoBoard.changeOH, {}, {}], // No output variable on success
    ),
    then: actions(
        [Requesting.respond, { request, status: "ok" }],
    ),
});

/**
 * ChangeOHResponseError:
 * when Requesting.request (path: "/brontoboard/officehours/change") : (request)
 *      BrontoBoard.changeOH () : (error)
 * then Requesting.respond (request, error)
 *
 * Responds to an error during Office Hours modification.
 */
export const ChangeOHResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/change" }, { request }],
        [BrontoBoard.changeOH, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

// --- Query Syncs for BrontoBoard Data ---

/**
 * GetAssignmentsForClassRequest:
 * when Requesting.request (path: "/brontoboard/class/assignments", session, class) : (request)
 * where in Sessioning: session is valid and maps to user
 *       in BrontoBoard: class.brontoBoardId is owned by user
 *       in BrontoBoard: _getAssignmentsForClass(class) gets assignments
 * then Requesting.respond (request, assignments, error)
 *
 * Handles requests to retrieve all assignments for a given class.
 * Requires an authenticated user and class ID. Authorizes by checking BrontoBoard ownership.
 */
export const GetAssignmentsForClassRequest: Sync = (
    { request, session, user, class: classId, assignments, error, classDoc, brontoBoardDoc },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/class/assignments", session, class: classId }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, user);
        if (frames.length === 0) return new Frames([{ ...originalFrame, [error]: "Authentication required: Invalid session." }]);

        // Get class document to find its parent BrontoBoard
        frames = await frames.query(BrontoBoard._getClassById, { class: classId }, { classDoc: classDoc });
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Class not found." }]);
        }

        // Get parent BrontoBoard document
        frames = await frames.query(BrontoBoard._getBrontoBoardById, { brontoBoard: frames[0][classDoc].brontoBoardId }, { brontoBoardDoc: brontoBoardDoc });
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Parent BrontoBoard not found for class." }]);
        }

        // Authorize: User must be the owner of the parent BrontoBoard
        frames = frames.filter(($) => $[brontoBoardDoc].owner === $[user]);
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Unauthorized access to class assignments." }]);
        }

        // Query for assignments
        frames = await frames.query(BrontoBoard._getAssignmentsForClass, { class: classId }, { assignment: assignments });

        // Collect results into a single 'assignments' array for the response
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [assignments]: [] }]);
        }
        return frames.collectAs([assignments], assignments); // collects all 'assignment' bindings into one 'assignments' array
    },
    then: actions(
        [Requesting.respond, { request, assignments, error }],
    ),
});

/**
 * GetOfficeHoursForClassRequest:
 * when Requesting.request (path: "/brontoboard/class/officehours", session, class) : (request)
 * where in Sessioning: session is valid and maps to user
 *       in BrontoBoard: class.brontoBoardId is owned by user
 *       in BrontoBoard: _getOfficeHoursForClass(class) gets officeHours
 * then Requesting.respond (request, officeHours, error)
 *
 * Handles requests to retrieve all office hours for a given class.
 * Requires an authenticated user and class ID. Authorizes by checking BrontoBoard ownership.
 */
export const GetOfficeHoursForClassRequest: Sync = (
    { request, session, user, class: classId, officeHours, error, classDoc, brontoBoardDoc },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/class/officehours", session, class: classId }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, user);
        if (frames.length === 0) return new Frames([{ ...originalFrame, [error]: "Authentication required: Invalid session." }]);

        frames = await frames.query(BrontoBoard._getClassById, { class: classId }, { classDoc: classDoc });
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Class not found." }]);
        }

        frames = await frames.query(BrontoBoard._getBrontoBoardById, { brontoBoard: frames[0][classDoc].brontoBoardId }, { brontoBoardDoc: brontoBoardDoc });
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Parent BrontoBoard not found for class." }]);
        }

        frames = frames.filter(($) => $[brontoBoardDoc].owner === $[user]);
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Unauthorized access to class office hours." }]);
        }

        frames = await frames.query(BrontoBoard._getOfficeHoursForClass, { class: classId }, { officeHour: officeHours });
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [officeHours]: [] }]);
        }
        return frames.collectAs([officeHours], officeHours);
    },
    then: actions(
        [Requesting.respond, { request, officeHours, error }],
    ),
});

/**
 * GetClassesForBrontoBoardRequest:
 * when Requesting.request (path: "/brontoboard/classes", session, brontoBoard) : (request)
 * where in Sessioning: session is valid and maps to user
 *       in BrontoBoard: brontoBoard is owned by user
 *       in BrontoBoard: _getClassesForBrontoBoard(brontoBoard) gets classes
 * then Requesting.respond (request, classes, error)
 *
 * Handles requests to retrieve all classes for a given BrontoBoard.
 * Requires an authenticated user and BrontoBoard ID. Authorizes by checking BrontoBoard ownership.
 */
export const GetClassesForBrontoBoardRequest: Sync = (
    { request, session, user, brontoBoard, classes, error, brontoBoardDoc },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/classes", session, brontoBoard }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, user);
        if (frames.length === 0) return new Frames([{ ...originalFrame, [error]: "Authentication required: Invalid session." }]);

        // Get BrontoBoard document to check ownership
        frames = await frames.query(BrontoBoard._getBrontoBoardById, { brontoBoard: brontoBoard }, { brontoBoardDoc: brontoBoardDoc });
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "BrontoBoard not found." }]);
        }

        // Authorize: User must be the owner of the BrontoBoard
        frames = frames.filter(($) => $[brontoBoardDoc].owner === $[user]);
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Unauthorized access to BrontoBoard classes." }]);
        }

        // Query for classes
        frames = await frames.query(BrontoBoard._getClassesForBrontoBoard, { brontoBoard: brontoBoard }, { class: classes });
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [classes]: [] }]);
        }
        return frames.collectAs([classes], classes);
    },
    then: actions(
        [Requesting.respond, { request, classes, error }],
    ),
});

/**
 * GetBrontoBoardsForUserRequest:
 * when Requesting.request (path: "/brontoboard/my-boards", session) : (request)
 * where in Sessioning: session is valid and maps to user
 *       in BrontoBoard: _getBrontoBoardsForUser(user) gets brontoBoards
 * then Requesting.respond (request, brontoBoards, error)
 *
 * Handles requests to retrieve all BrontoBoards owned by the authenticated user.
 * Requires an authenticated user.
 */
export const GetBrontoBoardsForUserRequest: Sync = (
    { request, session, user, brontoBoards, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/my-boards", session }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, user);
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [error]: "Authentication required: Invalid session." }]);
        }

        // Query for BrontoBoards owned by the user
        frames = await frames.query(BrontoBoard._getBrontoBoardsForUser, { user }, { brontoBoard: brontoBoards });
        if (frames.length === 0) {
            return new Frames([{ ...originalFrame, [brontoBoards]: [] }]);
        }
        return frames.collectAs([brontoBoards], brontoBoards);
    },
    then: actions(
        [Requesting.respond, { request, brontoBoards, error }],
    ),
});
```

***

**Explanation of Key Patterns:**

1. **`@concepts` Import:** Both sync files import `Requesting` (for handling HTTP requests), `UserAuthentication` (for auth logic), and `BrontoBoard` (for core functionality) from `@concepts`. `Sessioning` is also imported in `brontoboard.sync.ts` based on the assumption.
2. **Request Flow (`when` clause):**
   * The `when` clause always starts with `[Requesting.request, { path: "...", ... }, { request }]` to capture an incoming HTTP request and bind a unique `request` ID.
   * For response syncs, the `when` clause additionally matches on the concept action that just completed (e.g., `[UserAuthentication.register, {}, { user }]` for success, or `[UserAuthentication.register, {}, { error }]` for failure) and the original `request` to maintain flow context.
3. **Authentication and Authorization (`where` clause):**
   * For `BrontoBoard` actions and queries that require a user to be authenticated, a `where` clause is used.
   * The `getAuthenticatedUser` helper function (which queries `Sessioning._getUser`) is called first to bind the `user` ID.
   * If `getAuthenticatedUser` results in empty frames (meaning no authenticated user for the given session), an `error` is immediately bound to the `originalFrame` and returned, preventing further processing and sending an authentication error response.
   * For queries (`GetAssignmentsForClassRequest`, etc.), additional `query` and `filter` steps are added within the `where` clause to fetch associated data and perform ownership checks against the `user` bound earlier.
4. **Error Handling in `where`:** The pattern `new Frames([{ ...originalFrame, [error]: "..." }])` ensures that even when a `where` clause results in an empty set of frames (e.g., due to failed authentication or not finding data), the original `request` ID is preserved along with an `error` message, allowing the `then` clause to send an appropriate response.
5. **`collectAs` for Queries:** For query syncs, `frames.collectAs([variable1, variable2], resultsArrayName)` is used to aggregate potentially multiple results (e.g., multiple assignments, classes, or office hours) into a single array under a specified variable name (`resultsArrayName`), which is then returned in the `Requesting.respond` action.
6. **`then` clause:** This always involves `Requesting.respond` to send an HTTP response back to the client, using the `request` ID and the data (`user`, `brontoBoard`, `assignment`, `error`, etc.) bound in the `when` and `where` clauses.

Remember to update your `src/concepts/concepts.ts` (usually handled by `deno run build`) and potentially your `src/main.ts` to include these new sync files.
