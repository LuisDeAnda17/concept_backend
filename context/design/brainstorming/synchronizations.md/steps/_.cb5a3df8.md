---
timestamp: 'Mon Nov 03 2025 18:26:48 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251103_182648.774b8be5.md]]'
content_id: cb5a3df82366dcd6c04123ffe90a212726c5aed47522873e07194e0087b6f541
---

# Synchronization Implementations

These files would go into `src/syncs/`.

## file: src/syncs/auth.sync.ts

```typescript
import { actions, Sync, Frames } from "@engine";
import { Requesting, UserAuthentication } from "@concepts";
// Note: Sessioning is not directly involved in auth actions, but will be for BrontoBoard

// --- User Registration Syncs ---

/**
 * RegisterUserRequest: Sync to handle incoming HTTP requests for user registration.
 *
 * When a request for "/auth/register" comes in, trigger the UserAuthentication.register action.
 * Maps request payload (username, password) to action inputs.
 */
export const RegisterUserRequest: Sync = ({ request, username, password, user, error }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/register", username, password }, { request }],
    ),
    then: actions(
        [UserAuthentication.register, { username, password }, { user, error }],
    ),
});

/**
 * RegisterUserResponseSuccess: Sync to respond to a successful user registration.
 *
 * When a request for "/auth/register" was made AND the UserAuthentication.register
 * action successfully returned a `user` ID, respond to the original request with the `user` ID.
 */
export const RegisterUserResponseSuccess: Sync = ({ request, user }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/register" }, { request }],
        [UserAuthentication.register, {}, { user }], // Match on successful user creation (has 'user' output)
    ),
    then: actions(
        [Requesting.respond, { request, user }],
    ),
});

/**
 * RegisterUserResponseError: Sync to respond to a failed user registration.
 *
 * When a request for "/auth/register" was made AND the UserAuthentication.register
 * action returned an `error`, respond to the original request with that `error`.
 */
export const RegisterUserResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/register" }, { request }],
        [UserAuthentication.register, {}, { error }], // Match on error during registration (has 'error' output)
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

// --- User Authentication/Login Syncs ---

/**
 * AuthenticateUserRequest: Sync to handle incoming HTTP requests for user login.
 *
 * When a request for "/auth/login" comes in, trigger the UserAuthentication.authenticate action.
 * Maps request payload (username, password) to action inputs.
 */
export const AuthenticateUserRequest: Sync = ({ request, username, password, user, error }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/login", username, password }, { request }],
    ),
    then: actions(
        [UserAuthentication.authenticate, { username, password }, { user, error }],
    ),
});

/**
 * AuthenticateUserResponseSuccess: Sync to respond to a successful user authentication.
 *
 * When a request for "/auth/login" was made AND the UserAuthentication.authenticate
 * action successfully returned a `user` ID, respond to the original request with the `user` ID.
 */
export const AuthenticateUserResponseSuccess: Sync = ({ request, user }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/login" }, { request }],
        [UserAuthentication.authenticate, {}, { user }], // Match on successful authentication (has 'user' output)
    ),
    then: actions(
        [Requesting.respond, { request, user }],
    ),
});

/**
 * AuthenticateUserResponseError: Sync to respond to a failed user authentication.
 *
 * When a request for "/auth/login" was made AND the UserAuthentication.authenticate
 * action returned an `error`, respond to the original request with that `error`.
 */
export const AuthenticateUserResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/auth/login" }, { request }],
        [UserAuthentication.authenticate, {}, { error }], // Match on error during authentication (has 'error' output)
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

```

## file: src/syncs/brontoboard.sync.ts

```typescript
import { actions, Sync, Frames } from "@engine";
// Assume Sessioning concept exists and has a _getUser query
import { Requesting, Sessioning, BrontoBoard } from "@concepts";
import { ID } from "@utils/types.ts"; // Assuming ID is defined here

// --- Helper for authenticated user ---
// This function encapsulates the common pattern of retrieving a user ID from a session ID.
// It queries the Sessioning concept, binding the result to the 'user' symbol.
// If no user is found for the session, the frames array will become empty.
const getAuthenticatedUser = async (frames: Frames, sessionSymbol: symbol, userSymbol: symbol) => {
    return await frames.query(Sessioning._getUser, { session: sessionSymbol }, { user: userSymbol });
};

// --- BrontoBoard Initialization Syncs ---

/**
 * InitializeBrontoBoardRequest: Handles request to create a new BrontoBoard.
 * Requires an authenticated user and a calendar ID.
 */
export const InitializeBrontoBoardRequest: Sync = ({ request, session, user, calendar, brontoBoard, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/initialize", session, calendar }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0]; // Capture initial frame for potential error response
        frames = await getAuthenticatedUser(frames, session, user); // Get authenticated user
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "User not authenticated." });
        }
        return frames;
    },
    then: actions(
        [BrontoBoard.initializeBB, { user, calendar }, { brontoBoard, error }],
    ),
});

/**
 * InitializeBrontoBoardResponseSuccess: Responds to a successful BrontoBoard creation.
 */
export const InitializeBrontoBoardResponseSuccess: Sync = ({ request, brontoBoard }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/initialize" }, { request }],
        [BrontoBoard.initializeBB, {}, { brontoBoard }],
    ),
    then: actions(
        [Requesting.respond, { request, brontoBoard }],
    ),
});

/**
 * InitializeBrontoBoardResponseError: Responds to an error during BrontoBoard creation.
 */
export const InitializeBrontoBoardResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/initialize" }, { request }],
        [BrontoBoard.initializeBB, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

// --- Class Management Syncs ---

/**
 * CreateClassRequest: Handles request to create a new Class within a BrontoBoard.
 * Requires authenticated owner and BrontoBoard ID.
 */
export const CreateClassRequest: Sync = (
    { request, session, owner, brontoBoard, className, overview, class: classId, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/class/create", session, brontoBoard, className, overview }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "User not authenticated." });
        }
        // BrontoBoard.createClass action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.createClass, { owner, brontoBoard, className, overview }, { class: classId, error }],
    ),
});

/**
 * CreateClassResponseSuccess: Responds to a successful Class creation.
 */
export const CreateClassResponseSuccess: Sync = ({ request, class: classId }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/class/create" }, { request }],
        [BrontoBoard.createClass, {}, { class: classId }],
    ),
    then: actions(
        [Requesting.respond, { request, class: classId }],
    ),
});

/**
 * CreateClassResponseError: Responds to an error during Class creation.
 */
export const CreateClassResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/class/create" }, { request }],
        [BrontoBoard.createClass, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

// --- Assignment (Work) Management Syncs ---

/**
 * AddWorkRequest: Handles request to add a new Assignment to a Class.
 * Requires authenticated owner, Class ID, and assignment details.
 */
export const AddWorkRequest: Sync = (
    { request, session, owner, class: classId, workName, dueDate, assignment, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/add", session, class: classId, workName, dueDate }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "User not authenticated." });
        }
        // BrontoBoard.addWork action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.addWork, { owner, class: classId, workName, dueDate }, { assignment, error }],
    ),
});

/**
 * AddWorkResponseSuccess: Responds to a successful Assignment addition.
 */
export const AddWorkResponseSuccess: Sync = ({ request, assignment }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/add" }, { request }],
        [BrontoBoard.addWork, {}, { assignment }],
    ),
    then: actions(
        [Requesting.respond, { request, assignment }],
    ),
});

/**
 * AddWorkResponseError: Responds to an error during Assignment addition.
 */
export const AddWorkResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/add" }, { request }],
        [BrontoBoard.addWork, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

/**
 * ChangeWorkRequest: Handles request to change an existing Assignment's due date.
 * Requires authenticated owner and Assignment ID.
 */
export const ChangeWorkRequest: Sync = (
    { request, session, owner, work, dueDate, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/change", session, work, dueDate }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "User not authenticated." });
        }
        // BrontoBoard.changeWork action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.changeWork, { owner, work, dueDate }, { error }],
    ),
});

/**
 * ChangeWorkResponseSuccess: Responds to a successful Assignment modification.
 */
export const ChangeWorkResponseSuccess: Sync = ({ request }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/change" }, { request }],
        [BrontoBoard.changeWork, {}, {}], // No output variable on success
    ),
    then: actions(
        [Requesting.respond, { request, status: "ok" }],
    ),
});

/**
 * ChangeWorkResponseError: Responds to an error during Assignment modification.
 */
export const ChangeWorkResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/change" }, { request }],
        [BrontoBoard.changeWork, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

/**
 * RemoveWorkRequest: Handles request to remove an Assignment.
 * Requires authenticated owner and Assignment ID.
 */
export const RemoveWorkRequest: Sync = (
    { request, session, owner, work, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/remove", session, work }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "User not authenticated." });
        }
        // BrontoBoard.removeWork action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.removeWork, { owner, work }, { error }],
    ),
});

/**
 * RemoveWorkResponseSuccess: Responds to a successful Assignment removal.
 */
export const RemoveWorkResponseSuccess: Sync = ({ request }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/remove" }, { request }],
        [BrontoBoard.removeWork, {}, {}], // No output variable on success
    ),
    then: actions(
        [Requesting.respond, { request, status: "ok" }],
    ),
});

/**
 * RemoveWorkResponseError: Responds to an error during Assignment removal.
 */
export const RemoveWorkResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/work/remove" }, { request }],
        [BrontoBoard.removeWork, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

// --- Office Hours Management Syncs ---

/**
 * AddOHRequest: Handles request to add new Office Hours to a Class.
 * Requires authenticated owner, Class ID, and office hour details.
 */
export const AddOHRequest: Sync = (
    { request, session, owner, class: classId, OHTime, OHduration, officeHours, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/add", session, class: classId, OHTime, OHduration }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "User not authenticated." });
        }
        // BrontoBoard.addOH action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.addOH, { owner, class: classId, OHTime, OHduration }, { officeHours, error }],
    ),
});

/**
 * AddOHResponseSuccess: Responds to a successful Office Hours addition.
 */
export const AddOHResponseSuccess: Sync = ({ request, officeHours }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/add" }, { request }],
        [BrontoBoard.addOH, {}, { officeHours }],
    ),
    then: actions(
        [Requesting.respond, { request, officeHours }],
    ),
});

/**
 * AddOHResponseError: Responds to an error during Office Hours addition.
 */
export const AddOHResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/add" }, { request }],
        [BrontoBoard.addOH, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

/**
 * ChangeOHRequest: Handles request to change existing Office Hours.
 * Requires authenticated owner, Office Hour ID, and new details.
 */
export const ChangeOHRequest: Sync = (
    { request, session, owner, oh, newDate, newduration, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/change", session, oh, newDate, newduration }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, owner);
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "User not authenticated." });
        }
        // BrontoBoard.changeOH action handles ownership validation internally
        return frames;
    },
    then: actions(
        [BrontoBoard.changeOH, { owner, oh, newDate, newduration }, { error }],
    ),
});

/**
 * ChangeOHResponseSuccess: Responds to a successful Office Hours modification.
 */
export const ChangeOHResponseSuccess: Sync = ({ request }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/change" }, { request }],
        [BrontoBoard.changeOH, {}, {}], // No output variable on success
    ),
    then: actions(
        [Requesting.respond, { request, status: "ok" }],
    ),
});

/**
 * ChangeOHResponseError: Responds to an error during Office Hours modification.
 */
export const ChangeOHResponseError: Sync = ({ request, error }) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/officehours/change" }, { request }],
        [BrontoBoard.changeOH, {}, { error }],
    ),
    then: actions(
        [Requesting.respond, { request, error }],
    ),
});

// --- Query Syncs for BrontoBoard Data ---

/**
 * GetAssignmentsForClassRequest: Handles request to retrieve all assignments for a given class.
 * Requires authenticated user and class ID. Authorizes by checking BrontoBoard ownership.
 */
export const GetAssignmentsForClassRequest: Sync = (
    { request, session, user, class: classId, assignments, error, classDoc, brontoBoardDoc },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/class/assignments", session, class: classId }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, user);
        if (frames.length === 0) return new Frames({ ...originalFrame, [error]: "User not authenticated." });

        // Get class document to find its parent BrontoBoard
        frames = await frames.query(BrontoBoard._getClassById, { class: classId }, { classDoc: classDoc });
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "Class not found." });
        }

        // Get parent BrontoBoard document
        frames = await frames.query(BrontoBoard._getBrontoBoardById, { brontoBoard: classDoc.brontoBoardId }, { brontoBoardDoc: brontoBoardDoc });
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "Parent BrontoBoard not found for class." });
        }

        // Authorize: User must be the owner of the parent BrontoBoard
        frames = frames.filter(($) => $[brontoBoardDoc].owner === $[user]);
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "Unauthorized access to class assignments." });
        }

        // Query for assignments
        frames = await frames.query(BrontoBoard._getAssignmentsForClass, { class: classId }, { assignments: assignments });

        // Collect results or return empty array if none found
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [assignments]: [] });
        }
        return frames.collectAs([assignments], assignments);
    },
    then: actions(
        [Requesting.respond, { request, assignments, error }],
    ),
});

/**
 * GetOfficeHoursForClassRequest: Handles request to retrieve all office hours for a given class.
 * Requires authenticated user and class ID. Authorizes by checking BrontoBoard ownership.
 */
export const GetOfficeHoursForClassRequest: Sync = (
    { request, session, user, class: classId, officeHours, error, classDoc, brontoBoardDoc },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/class/officehours", session, class: classId }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, user);
        if (frames.length === 0) return new Frames({ ...originalFrame, [error]: "User not authenticated." });

        frames = await frames.query(BrontoBoard._getClassById, { class: classId }, { classDoc: classDoc });
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "Class not found." });
        }

        frames = await frames.query(BrontoBoard._getBrontoBoardById, { brontoBoard: classDoc.brontoBoardId }, { brontoBoardDoc: brontoBoardDoc });
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "Parent BrontoBoard not found for class." });
        }

        frames = frames.filter(($) => $[brontoBoardDoc].owner === $[user]);
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "Unauthorized access to class office hours." });
        }

        frames = await frames.query(BrontoBoard._getOfficeHoursForClass, { class: classId }, { officeHours: officeHours });
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [officeHours]: [] });
        }
        return frames.collectAs([officeHours], officeHours);
    },
    then: actions(
        [Requesting.respond, { request, officeHours, error }],
    ),
});

/**
 * GetClassesForBrontoBoardRequest: Handles request to retrieve all classes for a given BrontoBoard.
 * Requires authenticated user and BrontoBoard ID. Authorizes by checking BrontoBoard ownership.
 */
export const GetClassesForBrontoBoardRequest: Sync = (
    { request, session, user, brontoBoard, classes, error, brontoBoardDoc },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/classes", session, brontoBoard }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, user);
        if (frames.length === 0) return new Frames({ ...originalFrame, [error]: "User not authenticated." });

        // Get BrontoBoard document to check ownership
        frames = await frames.query(BrontoBoard._getBrontoBoardById, { brontoBoard: brontoBoard }, { brontoBoardDoc: brontoBoardDoc });
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "BrontoBoard not found." });
        }

        // Authorize: User must be the owner of the BrontoBoard
        frames = frames.filter(($) => $[brontoBoardDoc].owner === $[user]);
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "Unauthorized access to BrontoBoard classes." });
        }

        // Query for classes
        frames = await frames.query(BrontoBoard._getClassesForBrontoBoard, { brontoBoard: brontoBoard }, { classes: classes });
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [classes]: [] });
        }
        return frames.collectAs([classes], classes);
    },
    then: actions(
        [Requesting.respond, { request, classes, error }],
    ),
});

/**
 * GetBrontoBoardsForUserRequest: Handles request to retrieve all BrontoBoards owned by the authenticated user.
 * Requires authenticated user.
 */
export const GetBrontoBoardsForUserRequest: Sync = (
    { request, session, user, brontoBoards, error },
) => ({
    when: actions(
        [Requesting.request, { path: "/brontoboard/my-boards", session }, { request }],
    ),
    where: async (frames) => {
        const originalFrame = frames[0];
        frames = await getAuthenticatedUser(frames, session, user);
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [error]: "User not authenticated." });
        }

        // Query for BrontoBoards owned by the user
        frames = await frames.query(BrontoBoard._getBrontoBoardsForUser, { user }, { brontoBoards: brontoBoards });
        if (frames.length === 0) {
            return new Frames({ ...originalFrame, [brontoBoards]: [] });
        }
        return frames.collectAs([brontoBoards], brontoBoards);
    },
    then: actions(
        [Requesting.respond, { request, brontoBoards, error }],
    ),
});

```
