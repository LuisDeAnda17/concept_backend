---
timestamp: 'Mon Nov 03 2025 13:18:51 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251103_131851.f41355be.md]]'
content_id: 66607ae7993fa4c2e0f2b9411f1a848dad1795f69e72844bd2ace38c6e7e86c1
---

# response:

Here are the synchronizations for the `BrontoCalendar` concept. They are designed to map incoming HTTP requests (via the `Requesting` concept) to `BrontoCalendar` actions and queries, and then respond to the original request with the results or errors.

To use these synchronizations:

1. Save the code below as `src/syncs/brontoCalendar.sync.ts`.
2. Ensure your `src/concepts/concepts.ts` (generated by `deno run build`) correctly exports `BrontoCalendar`, `Requesting`, and `Sessioning`.
3. Run `deno run build` to update your imports.
4. Start your application with `deno run start`.

```typescript
// file: src/syncs/brontoCalendar.sync.ts

import { actions, Sync, Frames } from "@engine";
import { Requesting, Sessioning, BrontoCalendar } from "@concepts";
import { ID } from "@utils/types.ts";

// Helper type for consistent variable naming in syncs
type User = ID;
type CalendarRef = ID;
type AssignmentRef = ID;
type OfficeHoursRef = ID;
type ClassId = ID;

// --- Calendar Management Syncs ---

/**
 * Sync: CreateCalendarRequest
 * When a request to create a calendar comes in, and the user is authenticated via session,
 * trigger the BrontoCalendar.createCalendar action.
 *
 * Request: POST /api/calendar/create
 * Body: { session: "s123" }
 */
export const CreateCalendarRequest: Sync = ({ request, session, user }) => ({
  when: actions([
    Requesting.request,
    { path: "/api/calendar/create", session },
    { request },
  ]),
  where: async (frames) => {
    // Authorize: Get the user ID from the session.
    // This ensures only authenticated users can create a calendar.
    return await frames.query(Sessioning._getUser, { session }, { user });
  },
  then: actions([
    BrontoCalendar.createCalendar,
    { user }, // Pass the authenticated user as the owner
  ]),
});

/**
 * Sync: CreateCalendarResponse
 * Responds to a successful BrontoCalendar.createCalendar action.
 */
export const CreateCalendarResponse: Sync = ({ request, calendarId }) => ({
  when: actions(
    [Requesting.request, { path: "/api/calendar/create" }, { request }],
    [BrontoCalendar.createCalendar, {}, { calendarId }], // Matches a successful return with calendarId
  ),
  then: actions([
    Requesting.respond,
    { request, calendarId },
  ]),
});

/**
 * Sync: CreateCalendarResponseError
 * Responds to an erroneous BrontoCalendar.createCalendar action.
 */
export const CreateCalendarResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/api/calendar/create" }, { request }],
    [BrontoCalendar.createCalendar, {}, { error }], // Matches an error return
  ),
  then: actions([
    Requesting.respond,
    { request, error, status: 500 }, // Respond with a 500 status for errors
  ]),
});

// --- Assignment Management Syncs ---

/**
 * Sync: CreateAssignmentRequest
 * Handles requests to create a new assignment.
 * Requires authentication via session.
 *
 * Request: POST /api/assignment/create
 * Body: { classId: "c1", name: "Homework 1", dueDate: "2023-11-15T23:59:59Z", session: "s123" }
 */
export const CreateAssignmentRequest: Sync = ({ request, session, user, classId, name, dueDate }) => ({
  when: actions([
    Requesting.request,
    { path: "/api/assignment/create", session, classId, name, dueDate },
    { request },
  ]),
  where: async (frames) => {
    // Basic authorization: ensure user is logged in
    return await frames.query(Sessioning._getUser, { session }, { user });
  },
  then: actions([
    BrontoCalendar.createAssignment,
    { classId, name, dueDate: new Date(dueDate) }, // Convert dueDate string from request to Date object
  ]),
});

/**
 * Sync: CreateAssignmentResponse
 * Responds to a successful BrontoCalendar.createAssignment action.
 */
export const CreateAssignmentResponse: Sync = ({ request, assignmentId }) => ({
  when: actions(
    [Requesting.request, { path: "/api/assignment/create" }, { request }],
    [BrontoCalendar.createAssignment, {}, { assignmentId }],
  ),
  then: actions([
    Requesting.respond,
    { request, assignmentId },
  ]),
});

/**
 * Sync: CreateAssignmentResponseError
 * Responds to an erroneous BrontoCalendar.createAssignment action.
 */
export const CreateAssignmentResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/api/assignment/create" }, { request }],
    [BrontoCalendar.createAssignment, {}, { error }],
  ),
  then: actions([
    Requesting.respond,
    { request, error, status: 500 },
  ]),
});

/**
 * Sync: AssignWorkRequest
 * Handles requests to assign an existing assignment to a user's calendar.
 *
 * Request: POST /api/calendar/assign-work
 * Body: { assignmentId: "a1", session: "s123" }
 */
export const AssignWorkRequest: Sync = ({ request, session, user, assignmentId }) => ({
  when: actions([
    Requesting.request,
    { path: "/api/calendar/assign-work", session, assignmentId },
    { request },
  ]),
  where: async (frames) => {
    // Authorize: Get the user ID from the session. This user will be the `owner`.
    return await frames.query(Sessioning._getUser, { session }, { user });
  },
  then: actions([
    BrontoCalendar.assignWork,
    { owner: user, assignmentId },
  ]),
});

/**
 * Sync: AssignWorkResponse
 * Responds to a successful BrontoCalendar.assignWork action.
 */
export const AssignWorkResponse: Sync = ({ request }) => ({
  when: actions(
    [Requesting.request, { path: "/api/calendar/assign-work" }, { request }],
    [BrontoCalendar.assignWork, {}, {}], // Matches an empty successful return
  ),
  then: actions([
    Requesting.respond,
    { request, status: "success", message: "Assignment assigned to calendar." },
  ]),
});

/**
 * Sync: AssignWorkResponseError
 * Responds to an erroneous BrontoCalendar.assignWork action.
 */
export const AssignWorkResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/api/calendar/assign-work" }, { request }],
    [BrontoCalendar.assignWork, {}, { error }],
  ),
  then: actions([
    Requesting.respond,
    { request, error, status: 500 },
  ]),
});

/**
 * Sync: RemoveWorkRequest
 * Handles requests to remove an assignment from a user's calendar.
 *
 * Request: POST /api/calendar/remove-work
 * Body: { assignmentId: "a1", session: "s123" }
 */
export const RemoveWorkRequest: Sync = ({ request, session, user, assignmentId }) => ({
  when: actions([
    Requesting.request,
    { path: "/api/calendar/remove-work", session, assignmentId },
    { request },
  ]),
  where: async (frames) => {
    return await frames.query(Sessioning._getUser, { session }, { user });
  },
  then: actions([
    BrontoCalendar.removeWork,
    { owner: user, assignmentId },
  ]),
});

/**
 * Sync: RemoveWorkResponse
 * Responds to a successful BrontoCalendar.removeWork action.
 */
export const RemoveWorkResponse: Sync = ({ request }) => ({
  when: actions(
    [Requesting.request, { path: "/api/calendar/remove-work" }, { request }],
    [BrontoCalendar.removeWork, {}, {}],
  ),
  then: actions([
    Requesting.respond,
    { request, status: "success", message: "Assignment removed from calendar." },
  ]),
});

/**
 * Sync: RemoveWorkResponseError
 * Responds to an erroneous BrontoCalendar.removeWork action.
 */
export const RemoveWorkResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/api/calendar/remove-work" }, { request }],
    [BrontoCalendar.removeWork, {}, { error }],
  ),
  then: actions([
    Requesting.respond,
    { request, error, status: 500 },
  ]),
});

/**
 * Sync: DeleteAssignmentRequest
 * Handles requests to delete an assignment permanently from the concept's state.
 *
 * Request: POST /api/assignment/delete
 * Body: { assignmentId: "a1", session: "s123" }
 */
export const DeleteAssignmentRequest: Sync = ({ request, session, user, assignmentId }) => ({
  when: actions([
    Requesting.request,
    { path: "/api/assignment/delete", session, assignmentId },
    { request },
  ]),
  where: async (frames) => {
    // Authorization check, though deleteAssignment doesn't directly use 'user',
    // an authenticated endpoint typically requires a session.
    return await frames.query(Sessioning._getUser, { session }, { user });
  },
  then: actions([
    BrontoCalendar.deleteAssignment,
    { assignmentId },
  ]),
});

/**
 * Sync: DeleteAssignmentResponse
 * Responds to a successful BrontoCalendar.deleteAssignment action.
 */
export const DeleteAssignmentResponse: Sync = ({ request }) => ({
  when: actions(
    [Requesting.request, { path: "/api/assignment/delete" }, { request }],
    [BrontoCalendar.deleteAssignment, {}, {}],
  ),
  then: actions([
    Requesting.respond,
    { request, status: "success", message: "Assignment deleted." },
  ]),
});

/**
 * Sync: DeleteAssignmentResponseError
 * Responds to an erroneous BrontoCalendar.deleteAssignment action.
 */
export const DeleteAssignmentResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/api/assignment/delete" }, { request }],
    [BrontoCalendar.deleteAssignment, {}, { error }],
  ),
  then: actions([
    Requesting.respond,
    { request, error, status: 500 },
  ]),
});

// --- Office Hours Management Syncs ---

/**
 * Sync: CreateOfficeHoursRequest
 * Handles requests to create new office hours.
 * Requires authentication via session.
 *
 * Request: POST /api/office-hours/create
 * Body: { classId: "c1", startTime: "2023-11-15T10:00:00Z", duration: 60, session: "s123" }
 */
export const CreateOfficeHoursRequest: Sync = ({ request, session, user, classId, startTime, duration }) => ({
  when: actions([
    Requesting.request,
    { path: "/api/office-hours/create", session, classId, startTime, duration },
    { request },
  ]),
  where: async (frames) => {
    // Basic authorization: ensure user is logged in
    return await frames.query(Sessioning._getUser, { session }, { user });
  },
  then: actions([
    BrontoCalendar.createOfficeHours,
    { classId, startTime: new Date(startTime), duration }, // Convert startTime string to Date
  ]),
});

/**
 * Sync: CreateOfficeHoursResponse
 * Responds to a successful BrontoCalendar.createOfficeHours action.
 */
export const CreateOfficeHoursResponse: Sync = ({ request, officeHoursId }) => ({
  when: actions(
    [Requesting.request, { path: "/api/office-hours/create" }, { request }],
    [BrontoCalendar.createOfficeHours, {}, { officeHoursId }],
  ),
  then: actions([
    Requesting.respond,
    { request, officeHoursId },
  ]),
});

/**
 * Sync: CreateOfficeHoursResponseError
 * Responds to an erroneous BrontoCalendar.createOfficeHours action.
 */
export const CreateOfficeHoursResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/api/office-hours/create" }, { request }],
    [BrontoCalendar.createOfficeHours, {}, { error }],
  ),
  then: actions([
    Requesting.respond,
    { request, error, status: 500 },
  ]),
});

/**
 * Sync: AssignOHRequest
 * Handles requests to assign existing office hours to a user's calendar.
 *
 * Request: POST /api/calendar/assign-office-hours
 * Body: { officeHoursId: "oh1", session: "s123" }
 */
export const AssignOHRequest: Sync = ({ request, session, user, officeHoursId }) => ({
  when: actions([
    Requesting.request,
    { path: "/api/calendar/assign-office-hours", session, officeHoursId },
    { request },
  ]),
  where: async (frames) => {
    // Authorize: Get the user ID from the session. This user will be the `owner`.
    return await frames.query(Sessioning._getUser, { session }, { user });
  },
  then: actions([
    BrontoCalendar.assignOH,
    { owner: user, officeHoursId },
  ]),
});

/**
 * Sync: AssignOHResponse
 * Responds to a successful BrontoCalendar.assignOH action.
 */
export const AssignOHResponse: Sync = ({ request }) => ({
  when: actions(
    [Requesting.request, { path: "/api/calendar/assign-office-hours" }, { request }],
    [BrontoCalendar.assignOH, {}, {}],
  ),
  then: actions([
    Requesting.respond,
    { request, status: "success", message: "Office hours assigned to calendar." },
  ]),
});

/**
 * Sync: AssignOHResponseError
 * Responds to an erroneous BrontoCalendar.assignOH action.
 */
export const AssignOHResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/api/calendar/assign-office-hours" }, { request }],
    [BrontoCalendar.assignOH, {}, { error }],
  ),
  then: actions([
    Requesting.respond,
    { request, error, status: 500 },
  ]),
});

/**
 * Sync: ChangeOHRequest
 * Handles requests to change the details (date, duration) of existing office hours.
 *
 * Request: POST /api/office-hours/change
 * Body: { officeHoursId: "oh1", newDate: "2023-11-16T10:30:00Z", newDuration: 90, session: "s123" }
 */
export const ChangeOHRequest: Sync = ({ request, session, user, officeHoursId, newDate, newDuration }) => ({
  when: actions([
    Requesting.request,
    { path: "/api/office-hours/change", session, officeHoursId, newDate, newDuration },
    { request },
  ]),
  where: async (frames) => {
    return await frames.query(Sessioning._getUser, { session }, { user });
  },
  then: actions([
    BrontoCalendar.changeOH,
    { owner: user, officeHoursId, newDate: new Date(newDate), newDuration }, // Convert newDate string to Date
  ]),
});

/**
 * Sync: ChangeOHResponse
 * Responds to a successful BrontoCalendar.changeOH action.
 */
export const ChangeOHResponse: Sync = ({ request }) => ({
  when: actions(
    [Requesting.request, { path: "/api/office-hours/change" }, { request }],
    [BrontoCalendar.changeOH, {}, {}],
  ),
  then: actions([
    Requesting.respond,
    { request, status: "success", message: "Office hours updated." },
  ]),
});

/**
 * Sync: ChangeOHResponseError
 * Responds to an erroneous BrontoCalendar.changeOH action.
 */
export const ChangeOHResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/api/office-hours/change" }, { request }],
    [BrontoCalendar.changeOH, {}, { error }],
  ),
  then: actions([
    Requesting.respond,
    { request, error, status: 500 },
  ]),
});

/**
 * Sync: DeleteOfficeHoursRequest
 * Handles requests to delete office hours permanently from the concept's state.
 *
 * Request: POST /api/office-hours/delete
 * Body: { officeHoursId: "oh1", session: "s123" }
 */
export const DeleteOfficeHoursRequest: Sync = ({ request, session, user, officeHoursId }) => ({
  when: actions([
    Requesting.request,
    { path: "/api/office-hours/delete", session, officeHoursId },
    { request },
  ]),
  where: async (frames) => {
    return await frames.query(Sessioning._getUser, { session }, { user });
  },
  then: actions([
    BrontoCalendar.deleteOfficeHours,
    { officeHoursId },
  ]),
});

/**
 * Sync: DeleteOfficeHoursResponse
 * Responds to a successful BrontoCalendar.deleteOfficeHours action.
 */
export const DeleteOfficeHoursResponse: Sync = ({ request }) => ({
  when: actions(
    [Requesting.request, { path: "/api/office-hours/delete" }, { request }],
    [BrontoCalendar.deleteOfficeHours, {}, {}],
  ),
  then: actions([
    Requesting.respond,
    { request, status: "success", message: "Office hours deleted." },
  ]),
});

/**
 * Sync: DeleteOfficeHoursResponseError
 * Responds to an erroneous BrontoCalendar.deleteOfficeHours action.
 */
export const DeleteOfficeHoursResponseError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/api/office-hours/delete" }, { request }],
    [BrontoCalendar.deleteOfficeHours, {}, { error }],
  ),
  then: actions([
    Requesting.respond,
    { request, error, status: 500 },
  ]),
});

// --- Calendar Query Syncs ---

/**
 * Sync: GetCalendarDayContentRequest
 * Handles requests to retrieve all assignments and office hours for a specific day on a user's calendar.
 *
 * Request: GET /api/calendar/day-content?date=YYYY-MM-DD&session=s123
 */
export const GetCalendarDayContentRequest: Sync = (
  { request, session, user, date: dateString, calendar, assignments, officeHours, results, error },
) => ({
  when: actions([
    Requesting.request,
    { path: "/api/calendar/day-content", session, date: dateString }, // date is a string from query params
    { request },
  ]),
  where: async (frames) => {
    const originalFrame = frames[0]; // Capture original frame for returning request ID and handling empty cases

    // 1. Authorize: Get user from session
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    if (frames.length === 0) {
      // User not found/session invalid, respond with error
      return new Frames({ ...originalFrame, [results]: { error: "Invalid session or user not found." } });
    }

    // Parse the date string from the request into a Date object for concept queries.
    const requestDate = new Date(dateString);
    if (isNaN(requestDate.getTime())) {
      // Handle invalid date format from request
      return new Frames({ ...originalFrame, [results]: { error: "Invalid date format provided. Use YYYY-MM-DD." } });
    }

    // 2. Get the user's calendar
    // The query returns either a CalendarDoc or null.
    // If null, it produces 0 frames. We need to handle this to return an empty array gracefully.
    const calendarFrames = await frames.query(BrontoCalendar._getCalendarForUser, { user }, { calendar });

    if (calendarFrames.length === 0) {
      // No calendar found for the user, return empty results for the day.
      const response = { ...originalFrame, [results]: { assignments: [], officeHours: [] } };
      return new Frames(response);
    }
    
    // Continue with the frames that have the calendar
    frames = calendarFrames;

    // 3. Query for assignments on that day for that calendar
    // _getAssignmentsOnDay returns AssignmentDoc[] or { error: string }
    const assignmentResults = await frames.query(
      BrontoCalendar._getAssignmentsOnDay, 
      { calendarId: frames[0][calendar]._id, date: requestDate }, 
      { assignments }
    );
    // If _getAssignmentsOnDay returned an error, assignmentResults will have an error property,
    // which will be bound to the `error` variable here.
    if (assignmentResults[0] && assignmentResults[0][error]) {
      return new Frames({ ...originalFrame, [results]: { error: assignmentResults[0][error] } });
    }
    
    // 4. Query for office hours on that day for that calendar
    // _getOfficeHoursOnDay returns OfficeHoursDoc[] or { error: string }
    const officeHoursResults = await frames.query(
      BrontoCalendar._getOfficeHoursOnDay, 
      { calendarId: frames[0][calendar]._id, date: requestDate }, 
      { officeHours }
    );
    // If _getOfficeHoursOnDay returned an error, officeHoursResults will have an error property.
    if (officeHoursResults[0] && officeHoursResults[0][error]) {
      return new Frames({ ...originalFrame, [results]: { error: officeHoursResults[0][error] } });
    }

    // Combine results into a single frame's `results` binding for the response
    return frames.map(($) => ({
      ...$,
      [results]: {
        assignments: $[assignments] || [],
        officeHours: $[officeHours] || [],
      },
    }));
  },
  then: actions([
    Requesting.respond,
    { request, results },
  ]),
});
```
