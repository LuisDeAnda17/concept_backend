---
timestamp: 'Mon Nov 03 2025 19:43:49 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251103_194349.ca6dccea.md]]'
content_id: caac015cf4438acc698e9b096d16d1ea8e6c0fb042adbc886df049fbfda92d85
---

# Syncs Implementation

Now, all the synchronizations in one file:

```typescript
// file: src/syncs/brontoboard.sync.ts

import { actions, Frames, Sync } from "@engine";
import { BrontoBoard, Requesting, Sessioning } from "@concepts"; // Assuming these are generated
import { ID } from "@utils/types.ts";

type User = ID; // Define User as ID, consistent with BrontoBoard concept

// --- Helper Functions for Where Clauses ---

// Function to query a user from a session and verify ownership of a BrontoBoard
const verifyBrontoBoardOwnership = async (
  frames: Frames,
  sessionId: symbol,
  brontoBoardId: symbol,
  userSymbol: symbol,
) => {
  // Get the user from the session
  frames = await frames.query(Sessioning._getUser, { session: sessionId }, {
    user: userSymbol,
  });

  // Query the BrontoBoard and filter to ensure the user is the owner
  return frames.query(
    BrontoBoard._getBrontoBoardById,
    { brontoBoard: brontoBoardId },
    { owner: userSymbol }, // Ensures the owner of the BB is the user from the session
  );
};

// Function to query a user from a session and verify ownership of a Class's BrontoBoard
const verifyClassOwnership = async (
  frames: Frames,
  sessionId: symbol,
  classId: symbol,
  userSymbol: symbol,
) => {
  // Get the user from the session
  frames = await frames.query(Sessioning._getUser, { session: sessionId }, {
    user: userSymbol,
  });

  // Get the class document
  frames = await frames.query(BrontoBoard._getClassById, { class: classId }, {
    brontoBoardId: new Frames.Variable("brontoBoardId") as symbol,
  }); // Bind brontoBoardId from class

  // Filter to ensure the user is the owner of the associated BrontoBoard
  return frames.query(
    BrontoBoard._getBrontoBoardById,
    { brontoBoard: frames.vars.brontoBoardId },
    { owner: userSymbol },
  );
};

// Function to query a user from a session and verify ownership of an Assignment's BrontoBoard
const verifyAssignmentOwnership = async (
  frames: Frames,
  sessionId: symbol,
  assignmentId: symbol,
  userSymbol: symbol,
) => {
  // Get the user from the session
  frames = await frames.query(Sessioning._getUser, { session: sessionId }, {
    user: userSymbol,
  });

  // Get the assignment document to find its classId
  frames = await frames.query(
    BrontoBoard._getAssignmentById,
    { assignment: assignmentId },
    { classId: new Frames.Variable("classId") as symbol },
  ); // Bind classId from assignment

  // Get the class document to find its brontoBoardId
  frames = await frames.query(
    BrontoBoard._getClassById,
    { class: frames.vars.classId },
    { brontoBoardId: new Frames.Variable("brontoBoardId") as symbol },
  ); // Bind brontoBoardId from class

  // Filter to ensure the user is the owner of the associated BrontoBoard
  return frames.query(
    BrontoBoard._getBrontoBoardById,
    { brontoBoard: frames.vars.brontoBoardId },
    { owner: userSymbol },
  );
};

// Function to query a user from a session and verify ownership of OfficeHours' BrontoBoard
const verifyOfficeHourOwnership = async (
  frames: Frames,
  sessionId: symbol,
  officeHourId: symbol,
  userSymbol: symbol,
) => {
  // Get the user from the session
  frames = await frames.query(Sessioning._getUser, { session: sessionId }, {
    user: userSymbol,
  });

  // Get the office hour document to find its classId
  frames = await frames.query(
    BrontoBoard._getOfficeHourById,
    { officeHour: officeHourId },
    { classId: new Frames.Variable("classId") as symbol },
  ); // Bind classId from officeHour

  // Get the class document to find its brontoBoardId
  frames = await frames.query(
    BrontoBoard._getClassById,
    { class: frames.vars.classId },
    { brontoBoardId: new Frames.Variable("brontoBoardId") as symbol },
  ); // Bind brontoBoardId from class

  // Filter to ensure the user is the owner of the associated BrontoBoard
  return frames.query(
    BrontoBoard._getBrontoBoardById,
    { brontoBoard: frames.vars.brontoBoardId },
    { owner: userSymbol },
  );
};

// --- BrontoBoard Actions ---

export const InitializeBrontoBoard: Sync = (
  { request, session, user, calendar, brontoBoard, error },
) => ({
  when: actions([
    Requesting.request,
    { path: "/brontoboard/init", session, calendar },
    { request },
  ]),
  where: async (frames) => {
    // Get the user from the session
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    return frames;
  },
  then: actions(
    [BrontoBoard.initializeBB, { user, calendar }, { brontoBoard, error }],
  ),
});

export const RespondToInitializeBrontoBoard: Sync = (
  { request, brontoBoard },
) => ({
  when: actions(
    [Requesting.request, { path: "/brontoboard/init" }, { request }],
    [BrontoBoard.initializeBB, {}, { brontoBoard }],
  ),
  then: actions([Requesting.respond, { request, brontoBoard }]),
});

export const RespondToInitializeBrontoBoardError: Sync = (
  { request, error },
) => ({
  when: actions(
    [Requesting.request, { path: "/brontoboard/init" }, { request }],
    [BrontoBoard.initializeBB, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

// --- Class Actions ---

export const CreateClassRequest: Sync = (
  { request, session, user, brontoBoard, className, overview, class: classId, error },
) => ({
  when: actions([
    Requesting.request,
    { path: "/brontoboard/class/create", session, brontoBoard, className, overview },
    { request },
  ]),
  where: async (frames) => {
    // Verify session and BrontoBoard ownership
    return await verifyBrontoBoardOwnership(
      frames,
      session,
      brontoBoard,
      user,
    );
  },
  then: actions(
    [
      BrontoBoard.createClass,
      { owner: user, brontoBoard, className, overview },
      { class: classId, error },
    ],
  ),
});

export const RespondToCreateClass: Sync = ({ request, class: classId }) => ({
  when: actions(
    [Requesting.request, { path: "/brontoboard/class/create" }, { request }],
    [BrontoBoard.createClass, {}, { class: classId }],
  ),
  then: actions([Requesting.respond, { request, class: classId }]),
});

export const RespondToCreateClassError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/brontoboard/class/create" }, { request }],
    [BrontoBoard.createClass, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

// --- Assignment Actions ---

export const AddWorkRequest: Sync = (
  { request, session, user, class: classId, workName, dueDate, assignment, error },
) => ({
  when: actions([
    Requesting.request,
    { path: "/brontoboard/assignment/add", session, class: classId, workName, dueDate },
    { request },
  ]),
  where: async (frames) => {
    // Verify session and Class ownership
    return await verifyClassOwnership(frames, session, classId, user);
  },
  then: actions(
    [
      BrontoBoard.addWork,
      { owner: user, class: classId, workName, dueDate },
      { assignment, error },
    ],
  ),
});

export const RespondToAddWork: Sync = ({ request, assignment }) => ({
  when: actions(
    [Requesting.request, { path: "/brontoboard/assignment/add" }, { request }],
    [BrontoBoard.addWork, {}, { assignment }],
  ),
  then: actions([Requesting.respond, { request, assignment }]),
});

export const RespondToAddWorkError: Sync = ({ request, error }) => ({
  when: actions(
    [Requesting.request, { path: "/brontoboard/assignment/add" }, { request }],
    [BrontoBoard.addWork, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

export const ChangeWorkRequest: Sync = (
  { request, session, user, work, dueDate, error },
) => ({
  when: actions([
    Requesting.request,
    { path: "/brontoboard/assignment/change", session, work, dueDate },
    { request },
  ]),
  where: async (frames) => {
    // Verify session and Assignment ownership
    return await verifyAssignmentOwnership(frames, session, work, user);
  },
  then: actions(
    [BrontoBoard.changeWork, { owner: user, work, dueDate }, { error }],
  ),
});

export const RespondToChangeWork: Sync = ({ request }) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/brontoboard/assignment/change" },
      { request },
    ],
    [BrontoBoard.changeWork, {}, {}], // No specific return for success
  ),
  then: actions([Requesting.respond, { request, status: "success" }]),
});

export const RespondToChangeWorkError: Sync = ({ request, error }) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/brontoboard/assignment/change" },
      { request },
    ],
    [BrontoBoard.changeWork, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

export const RemoveWorkRequest: Sync = ({ request, session, user, work, error }) => ({
  when: actions([
    Requesting.request,
    { path: "/brontoboard/assignment/remove", session, work },
    { request },
  ]),
  where: async (frames) => {
    // Verify session and Assignment ownership
    return await verifyAssignmentOwnership(frames, session, work, user);
  },
  then: actions([BrontoBoard.removeWork, { owner: user, work }, { error }]),
});

export const RespondToRemoveWork: Sync = ({ request }) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/brontoboard/assignment/remove" },
      { request },
    ],
    [BrontoBoard.removeWork, {}, {}],
  ),
  then: actions([Requesting.respond, { request, status: "success" }]),
});

export const RespondToRemoveWorkError: Sync = ({ request, error }) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/brontoboard/assignment/remove" },
      { request },
    ],
    [BrontoBoard.removeWork, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

// --- Office Hours Actions ---

export const AddOHRequest: Sync = (
  { request, session, user, class: classId, OHTime, OHduration, officeHours, error },
) => ({
  when: actions([
    Requesting.request,
    { path: "/brontoboard/officehours/add", session, class: classId, OHTime, OHduration },
    { request },
  ]),
  where: async (frames) => {
    // Verify session and Class ownership
    return await verifyClassOwnership(frames, session, classId, user);
  },
  then: actions(
    [
      BrontoBoard.addOH,
      { owner: user, class: classId, OHTime, OHduration },
      { officeHours, error },
    ],
  ),
});

export const RespondToAddOH: Sync = ({ request, officeHours }) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/brontoboard/officehours/add" },
      { request },
    ],
    [BrontoBoard.addOH, {}, { officeHours }],
  ),
  then: actions([Requesting.respond, { request, officeHours }]),
});

export const RespondToAddOHError: Sync = ({ request, error }) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/brontoboard/officehours/add" },
      { request },
    ],
    [BrontoBoard.addOH, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

export const ChangeOHRequest: Sync = (
  { request, session, user, oh, newDate, newduration, error },
) => ({
  when: actions([
    Requesting.request,
    { path: "/brontoboard/officehours/change", session, oh, newDate, newduration },
    { request },
  ]),
  where: async (frames) => {
    // Verify session and Office Hour ownership
    return await verifyOfficeHourOwnership(frames, session, oh, user);
  },
  then: actions(
    [BrontoBoard.changeOH, { owner: user, oh, newDate, newduration }, { error }],
  ),
});

export const RespondToChangeOH: Sync = ({ request }) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/brontoboard/officehours/change" },
      { request },
    ],
    [BrontoBoard.changeOH, {}, {}], // No specific return for success
  ),
  then: actions([Requesting.respond, { request, status: "success" }]),
});

export const RespondToChangeOHError: Sync = ({ request, error }) => ({
  when: actions(
    [
      Requesting.request,
      { path: "/brontoboard/officehours/change" },
      { request },
    ],
    [BrontoBoard.changeOH, {}, { error }],
  ),
  then: actions([Requesting.respond, { request, error }]),
});

// --- Query Syncs (Read Operations) ---

export const ListMyBrontoBoardsRequest: Sync = (
  { request, session, user, brontoBoard, results },
) => ({
  when: actions([
    Requesting.request,
    { path: "/brontoboard/my-boards", session },
    { request },
  ]),
  where: async (frames) => {
    const originalFrame = frames[0]; // Capture original frame for empty results
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(
      BrontoBoard._getBrontoBoardsForUser,
      { user },
      { brontoBoard },
    );

    if (frames.length === 0) {
      return new Frames({ ...originalFrame, [results]: [] });
    }
    return frames.collectAs([brontoBoard], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});

export const ListClassesForBrontoBoardRequest: Sync = (
  { request, session, user, brontoBoard, class: classDoc, results },
) => ({
  when: actions([
    Requesting.request,
    { path: "/brontoboard/classes", session, brontoBoard },
    { request },
  ]),
  where: async (frames) => {
    const originalFrame = frames[0]; // Capture original frame for empty results
    frames = await verifyBrontoBoardOwnership(frames, session, brontoBoard, user);

    if (frames.length === 0) {
      // Not authorized or BrontoBoard not found, return an error frame or empty.
      return new Frames({ ...originalFrame, error: "Unauthorized or BrontoBoard not found." });
    }

    frames = await frames.query(
      BrontoBoard._getClassesForBrontoBoard,
      { brontoBoard },
      { class: classDoc },
    );

    if (frames.length === 0) {
      return new Frames({ ...originalFrame, [results]: [] });
    }
    return frames.collectAs([classDoc], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});

export const ListAssignmentsForClassRequest: Sync = (
  { request, session, user, class: classId, assignment, results },
) => ({
  when: actions([
    Requesting.request,
    { path: "/brontoboard/assignments", session, class: classId },
    { request },
  ]),
  where: async (frames) => {
    const originalFrame = frames[0]; // Capture original frame for empty results
    frames = await verifyClassOwnership(frames, session, classId, user);

    if (frames.length === 0) {
      return new Frames({ ...originalFrame, error: "Unauthorized or Class not found." });
    }

    frames = await frames.query(
      BrontoBoard._getAssignmentsForClass,
      { class: classId },
      { assignment },
    );

    if (frames.length === 0) {
      return new Frames({ ...originalFrame, [results]: [] });
    }
    return frames.collectAs([assignment], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});

export const ListOfficeHoursForClassRequest: Sync = (
  { request, session, user, class: classId, officeHour, results },
) => ({
  when: actions([
    Requesting.request,
    { path: "/brontoboard/officehours", session, class: classId },
    { request },
  ]),
  where: async (frames) => {
    const originalFrame = frames[0]; // Capture original frame for empty results
    frames = await verifyClassOwnership(frames, session, classId, user);

    if (frames.length === 0) {
      return new Frames({ ...originalFrame, error: "Unauthorized or Class not found." });
    }

    frames = await frames.query(
      BrontoBoard._getOfficeHoursForClass,
      { class: classId },
      { officeHour },
    );

    if (frames.length === 0) {
      return new Frames({ ...originalFrame, [results]: [] });
    }
    return frames.collectAs([officeHour], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});

```
