---
timestamp: 'Mon Nov 03 2025 15:38:26 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251103_153826.fba33a59.md]]'
content_id: 20eabdd457baec1322bebd2613e671b45f9302991a8d6f9517d4438b6fc33721
---

# Implementing Synchronizations for BrontoBoard

## file: src/syncs/brontoboard.sync.ts

```typescript
// These two help you declare synchronizations
import { actions, Sync, Frames } from "@engine";
// Choose whatever concepts you have
import { BrontoBoard, Requesting, UserAuthentication } from "@concepts"; // Assuming these are correctly generated by build script

// Define internal symbols for robust error handling within the helper
const AUTHENTICATION_ERROR_INTERNAL = Symbol('authenticationErrorInternal');
const AUTHORIZATION_ERROR_INTERNAL = Symbol('authorizationErrorInternal');

// -----------------------------------------------------------------------------
// Helper for Authentication and Authorization logic within `where` clauses
// This function encapsulates the common pattern of:
// 1. Authenticating a user based on username and password from the request.
// 2. Optionally authorizing that user against a specific BrontoBoard or Class.
//
// It ensures that the returned Frames object always contains the original request
// data, plus:
// - If auth/authz succeeds: 'user' (ID) and original request data, and 'error' is undefined.
// - If auth fails: 'error' bound with authentication message.
// - If authz fails: 'error' bound with authorization message.
// - If entity data not found for authz: 'error' bound with appropriate message.
//
// This allows the `then` clause to use a single 'error' variable which will
// either be an error string or undefined (for success).
// -----------------------------------------------------------------------------
async function authenticateAndAuthorizeFrames(
  initialFrames: Frames,
  requestSymbol: symbol,
  usernameSymbol: symbol,
  passwordSymbol: symbol,
  userSymbol: symbol, // Symbol to bind the authenticated user ID (output)
  errorSymbol: symbol, // Symbol to bind any authentication/authorization error (output)
  context: {
    entityType?: 'brontoBoard' | 'class' | 'assignment' | 'officeHour'; // Type of entity to authorize against
    entityIdSymbol?: symbol; // The symbol for the entity ID (e.g., brontoBoard, class) in the output frame if authz passes
    entityIdToQuery?: symbol; // The symbol from the input frame to get the entity ID value for queries
    conceptInstance: BrontoBoard; // Instance of BrontoBoardConcept for queries
  },
): Promise<Frames> {
  const originalRequestFrame = initialFrames[0];
  if (!originalRequestFrame) {
    return new Frames(); // Should not happen if a request came in
  }

  // Preserve the original request details and add a placeholder for user and error
  let currentFrame: Record<symbol, unknown> = { ...originalRequestFrame, [userSymbol]: undefined, [errorSymbol]: undefined };
  let processedFrames = new Frames(currentFrame);

  // 1. Authenticate the user
  const authResults = await initialFrames.query(
    UserAuthentication.authenticate,
    { username: originalRequestFrame[usernameSymbol], password: originalRequestFrame[passwordSymbol] },
    { user: userSymbol, error: AUTHENTICATION_ERROR_INTERNAL }, // Bind to internal error symbol
  );

  // If authentication failed, update the error and return
  if (authResults.filter(($) => $[AUTHENTICATION_ERROR_INTERNAL] !== undefined).length > 0) {
    currentFrame[errorSymbol] = authResults[0][AUTHENTICATION_ERROR_INTERNAL];
    return new Frames(currentFrame);
  }

  // Authentication succeeded, bind the user ID
  currentFrame[userSymbol] = authResults[0][userSymbol];
  const authenticatedUserId = currentFrame[userSymbol] as ID;
  processedFrames = new Frames(currentFrame);

  // 2. Perform Authorization if required
  if (context.entityType && context.entityIdSymbol && context.entityIdToQuery && authenticatedUserId) {
    const entityIdValue = originalRequestFrame[context.entityIdToQuery];

    if (!entityIdValue) {
      currentFrame[errorSymbol] = `Missing ${String(context.entityIdToQuery).replace(/Symbol\((.*)\)/, '$1')} for authorization.`;
      return new Frames(currentFrame);
    }

    let authorizedFrames: Frames = new Frames();
    let classIdForAuthz: ID | undefined;

    if (context.entityType === 'assignment' || context.entityType === 'officeHour') {
      // For assignment/officeHour, first get its associated class ID
      if (context.entityType === 'assignment') {
        const assignmentResults = await processedFrames.query(
          context.conceptInstance._getAssignmentById,
          { assignment: entityIdValue },
          { class: Symbol('tempClassId') }, // Temporary symbol for class ID
        );
        if (assignmentResults.length === 0 || !assignmentResults[0][Symbol('tempClassId')]) {
          currentFrame[errorSymbol] = `${context.entityType} with ID ${entityIdValue} not found.`;
          return new Frames(currentFrame);
        }
        classIdForAuthz = assignmentResults[0][Symbol('tempClassId')] as ID;
      } else if (context.entityType === 'officeHour') {
        const officeHourResults = await processedFrames.query(
          context.conceptInstance._getOfficeHourById,
          { officeHour: entityIdValue },
          { class: Symbol('tempClassId') }, // Temporary symbol for class ID
        );
        if (officeHourResults.length === 0 || !officeHourResults[0][Symbol('tempClassId')]) {
          currentFrame[errorSymbol] = `${context.entityType} with ID ${entityIdValue} not found.`;
          return new Frames(currentFrame);
        }
        classIdForAuthz = officeHourResults[0][Symbol('tempClassId')] as ID;
      }

      // Now authorize based on class ownership
      if (classIdForAuthz) {
        authorizedFrames = await processedFrames.query(
          context.conceptInstance._isClassOwner,
          { class: classIdForAuthz, user: authenticatedUserId },
          { class: context.entityIdSymbol }, // Output the class ID if owner (or just a placeholder)
        );
      } else {
         currentFrame[errorSymbol] = `Could not determine class for ${context.entityType}.`;
         return new Frames(currentFrame);
      }
    } else if (context.entityType === 'brontoBoard') {
      authorizedFrames = await processedFrames.query(
        context.conceptInstance._isBrontoBoardOwner,
        { brontoBoard: entityIdValue, user: authenticatedUserId },
        { brontoBoard: context.entityIdSymbol }, // Output the brontoBoard ID if owner
      );
    } else if (context.entityType === 'class') {
      authorizedFrames = await processedFrames.query(
        context.conceptInstance._isClassOwner,
        { class: entityIdValue, user: authenticatedUserId },
        { class: context.entityIdSymbol }, // Output the class ID if owner
      );
    }

    // If authorization failed (query returned no frames)
    if (authorizedFrames.length === 0) {
      currentFrame[errorSymbol] = `User not authorized to access this ${context.entityType}.`;
      return new Frames(currentFrame);
    }

    // Authorization successful, merge back authorized entity ID if applicable
    if (context.entityIdSymbol) {
      currentFrame[context.entityIdSymbol] = authorizedFrames[0][context.entityIdSymbol];
    }
  }

  // If no authorization was required, or it succeeded, return the updated frame (with error undefined)
  currentFrame[errorSymbol] = undefined; // Ensure error is cleared if successful
  return new Frames(currentFrame);
}


// -----------------------------------------------------------------------------
// 1. Initialize BrontoBoard
// Path: /brontoboards/initialize (POST)
// Input: { username, password, calendar }
// Output: { brontoBoard: ID } | { error: string }
// -----------------------------------------------------------------------------

export const InitializeBrontoBoardRequest: Sync = ({
  request, username, password, calendar, brontoBoard, user, error,
}) => ({
  when: actions(
    [Requesting.request, {
      path: "/brontoboards/initialize",
      username,
      password,
      calendar,
    }, { request }],
  ),
  where: async (frames) => {
    // Perform authentication only (no specific entity authorization for initialization)
    return await authenticateAndAuthorizeFrames(
      frames,
      request, username, password, user, error,
      { conceptInstance: BrontoBoard },
    );
  },
  then: actions(
    // If 'error' is bound in frames (auth failed), BrontoBoard.initializeBB won't execute (due to its own internal owner check)
    // or its own error if it returned one. Requesting.respond handles the propagated error.
    [BrontoBoard.initializeBB, { owner: user, calendar }, { brontoBoard, error }],
    [Requesting.respond, { request, brontoBoard, error }],
  ),
});


// -----------------------------------------------------------------------------
// 2. Create Class
// Path: /brontoboards/class/create (POST)
// Input: { username, password, brontoBoard, className, overview }
// Output: { class: ID } | { error: string }
// -----------------------------------------------------------------------------

export const CreateClassRequest: Sync = ({
  request, username, password, brontoBoard, className, overview, user, error, class: classId,
}) => ({
  when: actions(
    [Requesting.request, {
      path: "/brontoboards/class/create",
      username,
      password,
      brontoBoard, // This is the ID of the BrontoBoard to which the class will be added
      className,
      overview,
    }, { request }],
  ),
  where: async (frames) => {
    // Authenticate and authorize (user must own the target BrontoBoard)
    return await authenticateAndAuthorizeFrames(
      frames,
      request, username, password, user, error,
      {
        entityType: 'brontoBoard',
        entityIdSymbol: brontoBoard, // The symbol for BrontoBoard ID in the output frame
        entityIdToQuery: brontoBoard, // The symbol from the input frame to get the BrontoBoard ID
        conceptInstance: BrontoBoard,
      },
    );
  },
  then: actions(
    [BrontoBoard.createClass, { owner: user, brontoBoard, className, overview }, { class: classId, error }],
    [Requesting.respond, { request, class: classId, error }],
  ),
});


// -----------------------------------------------------------------------------
// 3. Add Assignment (addWork)
// Path: /brontoboards/assignment/add (POST)
// Input: { username, password, class, workName, dueDate }
// Output: { assignment: ID } | { error: string }
// -----------------------------------------------------------------------------

export const AddAssignmentRequest: Sync = ({
  request, username, password, class: classId, workName, dueDate, user, error, assignment,
}) => ({
  when: actions(
    [Requesting.request, {
      path: "/brontoboards/assignment/add",
      username,
      password,
      class: classId, // This is the ID of the class to which the assignment will be added
      workName,
      dueDate,
    }, { request }],
  ),
  where: async (frames) => {
    // Authenticate and authorize (user must own the BrontoBoard associated with the target class)
    return await authenticateAndAuthorizeFrames(
      frames,
      request, username, password, user, error,
      {
        entityType: 'class',
        entityIdSymbol: classId, // The symbol for Class ID in the output frame (could be a temp, or same as input if not changing)
        entityIdToQuery: classId, // The symbol from the input frame to get the Class ID
        conceptInstance: BrontoBoard,
      },
    );
  },
  then: actions(
    [BrontoBoard.addWork, { owner: user, class: classId, workName, dueDate }, { assignment, error }],
    [Requesting.respond, { request, assignment, error }],
  ),
});


// -----------------------------------------------------------------------------
// 4. Change Assignment (changeWork)
// Path: /brontoboards/assignment/change (POST)
// Input: { username, password, work, dueDate }
// Output: { status: string } | { error: string }
// -----------------------------------------------------------------------------

export const ChangeAssignmentRequest: Sync = ({
  request, username, password, work, dueDate, user, error,
}) => ({
  when: actions(
    [Requesting.request, {
      path: "/brontoboards/assignment/change",
      username,
      password,
      work, // This is the ID of the assignment to change
      dueDate,
    }, { request }],
  ),
  where: async (frames) => {
    // Authenticate and authorize (user must own the BrontoBoard associated with the target assignment's class)
    return await authenticateAndAuthorizeFrames(
      frames,
      request, username, password, user, error,
      {
        entityType: 'assignment',
        entityIdSymbol: work, // The symbol for Assignment ID in the output frame
        entityIdToQuery: work, // The symbol from the input frame to get the Assignment ID
        conceptInstance: BrontoBoard,
      },
    );
  },
  then: actions(
    [BrontoBoard.changeWork, { owner: user, work, dueDate }, { error }],
    [Requesting.respond, {
      request,
      status: error ? undefined : "Assignment updated successfully.",
      error,
    }],
  ),
});


// -----------------------------------------------------------------------------
// 5. Remove Assignment (removeWork)
// Path: /brontoboards/assignment/remove (POST)
// Input: { username, password, work }
// Output: { status: string } | { error: string }
// -----------------------------------------------------------------------------

export const RemoveAssignmentRequest: Sync = ({
  request, username, password, work, user, error,
}) => ({
  when: actions(
    [Requesting.request, {
      path: "/brontoboards/assignment/remove",
      username,
      password,
      work, // ID of the assignment to remove
    }, { request }],
  ),
  where: async (frames) => {
    // Authenticate and authorize (user must own the BrontoBoard associated with the target assignment's class)
    return await authenticateAndAuthorizeFrames(
      frames,
      request, username, password, user, error,
      {
        entityType: 'assignment',
        entityIdSymbol: work, // The symbol for Assignment ID in the output frame
        entityIdToQuery: work, // The symbol from the input frame to get the Assignment ID
        conceptInstance: BrontoBoard,
      },
    );
  },
  then: actions(
    [BrontoBoard.removeWork, { owner: user, work }, { error }],
    [Requesting.respond, {
      request,
      status: error ? undefined : "Assignment removed successfully.",
      error,
    }],
  ),
});


// -----------------------------------------------------------------------------
// 6. Add Office Hours (addOH)
// Path: /brontoboards/officehours/add (POST)
// Input: { username, password, class, OHTime, OHduration }
// Output: { officeHours: ID } | { error: string }
// -----------------------------------------------------------------------------

export const AddOfficeHoursRequest: Sync = ({
  request, username, password, class: classId, OHTime, OHduration, user, error, officeHours,
}) => ({
  when: actions(
    [Requesting.request, {
      path: "/brontoboards/officehours/add",
      username,
      password,
      class: classId,
      OHTime,
      OHduration,
    }, { request }],
  ),
  where: async (frames) => {
    // Authenticate and authorize (user must own the BrontoBoard associated with the target class)
    return await authenticateAndAuthorizeFrames(
      frames,
      request, username, password, user, error,
      {
        entityType: 'class',
        entityIdSymbol: classId,
        entityIdToQuery: classId,
        conceptInstance: BrontoBoard,
      },
    );
  },
  then: actions(
    [BrontoBoard.addOH, { owner: user, class: classId, OHTime, OHduration }, { officeHours, error }],
    [Requesting.respond, { request, officeHours, error }],
  ),
});


// -----------------------------------------------------------------------------
// 7. Change Office Hours (changeOH)
// Path: /brontoboards/officehours/change (POST)
// Input: { username, password, oh, newDate, newduration }
// Output: { status: string } | { error: string }
// -----------------------------------------------------------------------------

export const ChangeOfficeHoursRequest: Sync = ({
  request, username, password, oh, newDate, newduration, user, error,
}) => ({
  when: actions(
    [Requesting.request, {
      path: "/brontoboards/officehours/change",
      username,
      password,
      oh, // ID of the office hour to change
      newDate,
      newduration,
    }, { request }],
  ),
  where: async (frames) => {
    // Authenticate and authorize (user must own the BrontoBoard associated with the target office hour's class)
    return await authenticateAndAuthorizeFrames(
      frames,
      request, username, password, user, error,
      {
        entityType: 'officeHour',
        entityIdSymbol: oh, // The symbol for Office Hour ID in the output frame
        entityIdToQuery: oh, // The symbol from the input frame to get the Office Hour ID
        conceptInstance: BrontoBoard,
      },
    );
  },
  then: actions(
    [BrontoBoard.changeOH, { owner: user, oh, newDate, newduration }, { error }],
    [Requesting.respond, {
      request,
      status: error ? undefined : "Office hours updated successfully.",
      error,
    }],
  ),
});


// -----------------------------------------------------------------------------
// Get Classes for a BrontoBoard (Query Example)
// Path: /brontoboards/classes (GET/POST, assuming POST for auth credentials)
// Input: { username, password, brontoBoard }
// Output: { results: ClassDoc[] } | { error: string }
// -----------------------------------------------------------------------------

export const GetClassesRequest: Sync = ({
  request, username, password, brontoBoard, user, error, results, classes
}) => ({
  when: actions(
    [Requesting.request, {
      path: "/brontoboards/classes",
      username,
      password,
      brontoBoard,
    }, { request }],
  ),
  where: async (frames) => {
    const originalRequestFrame = frames[0];
    
    // Authenticate and authorize (user must own the target BrontoBoard)
    let processedFrames = await authenticateAndAuthorizeFrames(
      frames,
      request, username, password, user, error,
      {
        entityType: 'brontoBoard',
        entityIdSymbol: brontoBoard,
        entityIdToQuery: brontoBoard,
        conceptInstance: BrontoBoard,
      },
    );

    // If authentication or authorization failed, return the error frame
    if (processedFrames.filter(($) => $[error] !== undefined).length > 0) {
        return processedFrames;
    }

    // At this point, 'user' is bound and authorization for 'brontoBoard' succeeded.
    // Query for classes
    processedFrames = await processedFrames.query(
      BrontoBoard._getClassesForBrontoBoard,
      { brontoBoard: originalRequestFrame[brontoBoard] },
      { class: classes }, // Bind individual class objects
    );

    // Collect all classes into a 'results' array
    // Handle zero matches: if no classes, return an empty array for results to prevent timeout.
    if (processedFrames.length === 0) {
        return new Frames({ ...originalRequestFrame, [user]: processedFrames[0]?.[user], [results]: [], [error]: undefined });
    }
    
    return processedFrames.collectAs([classes], results);
  },
  then: actions(
    [Requesting.respond, {
      request,
      results,
      error,
    }],
  ),
});
```
